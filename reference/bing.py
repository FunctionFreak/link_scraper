import asyncio
from playwright.async_api import async_playwright

async def inject_bing_h2_highlighter(page):
    """Inject JavaScript for highlighting Bing H2 search results with persistent numbering"""
    
    js_code = """
    () => {
        console.log('Injecting Bing H2 highlighter with persistent numbering...');
        
        // Avoid re-injection
        if (window.bingH2HighlighterInjected) {
            console.log('Bing H2 highlighter already injected');
            return 'Already injected';
        }
        window.bingH2HighlighterInjected = true;
        
        // Global persistent numbering system
        let globalLinkCounter = 0;  // This never resets
        let processedLinks = new Map();  // Track which links we've seen before
        let activeHighlights = new Map();  // Currently visible highlights
        let isHighlightingActive = false;
        
        // Function to generate unique identifier for an H2 element
        function getElementId(h2) {
            // Use text content + position in DOM as unique identifier
            const text = h2.textContent.trim();
            const rect = h2.getBoundingClientRect();
            const parentText = h2.parentElement ? h2.parentElement.textContent.trim().substring(0, 50) : '';
            
            // Create a unique ID based on content and context
            return `${text.substring(0, 100)}_${parentText}_${h2.tagName}`;
        }
        
        // Function to check if element is visible
        function isElementVisible(element) {
            if (!element) return false;
            
            const rect = element.getBoundingClientRect();
            
            // Check if element has size
            if (rect.width === 0 || rect.height === 0) return false;
            
            // Check if in viewport
            const inViewport = (
                rect.top < (window.innerHeight || document.documentElement.clientHeight) &&
                rect.bottom > 0 &&
                rect.left < (window.innerWidth || document.documentElement.clientWidth) &&
                rect.right > 0
            );
            
            if (!inViewport) return false;
            
            // Check CSS visibility
            const style = window.getComputedStyle(element);
            if (style.display === 'none' || 
                style.visibility === 'hidden' || 
                style.opacity === '0') {
                return false;
            }
            
            return true;
        }
        
        // Function to check if H2 has link
        function h2HasLink(h2) {
            return h2.querySelector('a') !== null || h2.closest('a') !== null;
        }
        
        // Function to check if H2 is organic search result (not AI summary, sponsored, or promotional)
        function isOrganicSearchResult(h2) {
            if (!h2) return false;
            
            // First, check if it's in a clear organic search result container
            const organicContainer = h2.closest('.b_algo, .b_algoheader, li.b_algo, div.b_algo');
            if (organicContainer) {
                // If it's in a b_algo container, it's likely organic
                console.log('Found H2 in organic container:', h2.textContent.trim().substring(0, 50));
                return true;
            }
            
            // Get the text content and surrounding elements
            const text = h2.textContent.trim().toLowerCase();
            
            // Check for AI summary indicators in text
            const aiSummaryKeywords = [
                'ai summary', 'ai-generated', 'generated by ai', 'copilot', 'chatgpt',
                'ai overview', 'ai response', 'generated summary', 'ai-powered',
                'artificial intelligence', 'machine learning', 'auto-generated'
            ];
            
            // Check for sponsored/promotional indicators in text
            const sponsoredKeywords = [
                'sponsored', 'advertisement', 'promoted', 'ad', 'ads',
                'promotion', 'promotional', 'partner', 'affiliate'
            ];
            
            // Check text content for AI/sponsored keywords
            for (const keyword of [...aiSummaryKeywords, ...sponsoredKeywords]) {
                if (text.includes(keyword)) {
                    console.log('Rejected H2 due to keyword:', keyword, h2.textContent.trim().substring(0, 50));
                    return false;
                }
            }
            
            // Check parent elements for AI/sponsored classes and attributes
            let currentElement = h2;
            for (let i = 0; i < 5; i++) { // Check up to 5 parent levels
                if (!currentElement) break;
                
                const className = currentElement.className ? currentElement.className.toLowerCase() : '';
                const id = currentElement.id ? currentElement.id.toLowerCase() : '';
                
                // Explicitly exclude known non-organic containers
                if (className.includes('b_ad') || 
                    className.includes('b_sponsored') ||
                    className.includes('b_promotion') ||
                    className.includes('b_ai') ||
                    className.includes('b_copilot') ||
                    className.includes('b_summary') ||
                    className.includes('sidebar') ||
                    className.includes('related') ||
                    className.includes('carousel') ||
                    id.includes('sidebar') ||
                    id.includes('related')) {
                    console.log('Rejected H2 due to non-organic container:', className, h2.textContent.trim().substring(0, 50));
                    return false;
                }
                
                currentElement = currentElement.parentElement;
            }
            
            // Check the link itself
            const link = h2.querySelector('a') || h2.closest('a');
            if (link) {
                const href = link.href;
                
                // Skip internal Bing links or AI-related links
                if (href && (
                    href.includes('bing.com') ||
                    href.includes('microsoft.com') ||
                    href.includes('copilot') ||
                    href.includes('chatgpt') ||
                    href.includes('#') ||
                    href.startsWith('javascript:')
                )) {
                    console.log('Rejected H2 due to internal link:', href, h2.textContent.trim().substring(0, 50));
                    return false;
                }
                
                // Check if it's a real external link
                if (href && (href.startsWith('http://') || href.startsWith('https://'))) {
                    console.log('Accepted H2 with external link:', href, h2.textContent.trim().substring(0, 50));
                    return true;
                }
            }
            
            // If we reach here, it's likely organic but not in a clear container
            // Be more permissive for H2 elements that seem like search results
            if (h2.querySelector('a') && h2.textContent.trim().length > 10) {
                console.log('Accepted H2 as likely organic:', h2.textContent.trim().substring(0, 50));
                return true;
            }
            
            console.log('Rejected H2 - no clear organic indicators:', h2.textContent.trim().substring(0, 50));
            return false;
        }
        
        // Function to create highlight for H2
        function createHighlight(h2, linkNumber) {
            const rect = h2.getBoundingClientRect();
            
            const highlight = document.createElement('div');
            highlight.className = 'bing-h2-highlight';
            highlight.setAttribute('data-link-number', linkNumber);
            
            // Style the highlight box
            Object.assign(highlight.style, {
                position: 'fixed',
                top: rect.top + 'px',
                left: rect.left + 'px',
                width: rect.width + 'px',
                height: rect.height + 'px',
                border: '3px solid #0078d4',
                backgroundColor: 'rgba(0, 120, 212, 0.1)',
                pointerEvents: 'none',
                zIndex: '9999',
                boxSizing: 'border-box'
            });
            
            // Add label with persistent number
            const label = document.createElement('div');
            Object.assign(label.style, {
                position: 'absolute',
                top: '-25px',
                left: '0',
                backgroundColor: '#0078d4',
                color: 'white',
                padding: '2px 8px',
                fontSize: '12px',
                fontFamily: 'Arial, sans-serif',
                borderRadius: '3px',
                whiteSpace: 'nowrap',
                pointerEvents: 'none',
                fontWeight: 'bold'
            });
            label.textContent = `H2 Link ${linkNumber}`;
            
            highlight.appendChild(label);
            document.body.appendChild(highlight);
            
            return highlight;
        }
        
        // Function to update highlight position
        function updateHighlight(h2, highlight) {
            if (!highlight || !document.body.contains(highlight)) return;
            
            const rect = h2.getBoundingClientRect();
            Object.assign(highlight.style, {
                top: rect.top + 'px',
                left: rect.left + 'px',
                width: rect.width + 'px',
                height: rect.height + 'px'
            });
        }
        
        // Function to process all H2 elements with persistent numbering
        function processH2Elements() {
            if (!isHighlightingActive) return;
            
            const h2Elements = document.querySelectorAll('h2');
            const currentlyVisible = new Set();
            
            h2Elements.forEach(h2 => {
                if (!h2HasLink(h2)) return;
                if (!isOrganicSearchResult(h2)) return; // Skip AI summaries, sponsored content, etc.
                
                const elementId = getElementId(h2);
                const isVisible = isElementVisible(h2);
                
                if (isVisible) {
                    currentlyVisible.add(elementId);
                    
                    // Check if this is a new link we haven't seen before
                    if (!processedLinks.has(elementId)) {
                        // New link - assign next number
                        globalLinkCounter++;
                        processedLinks.set(elementId, {
                            number: globalLinkCounter,
                            element: h2,
                            firstSeen: Date.now()
                        });
                        
                        console.log(`New ORGANIC H2 link discovered: #${globalLinkCounter} - "${h2.textContent.trim().substring(0, 50)}..."`);
                    }
                    
                    const linkData = processedLinks.get(elementId);
                    
                    // Create or update highlight
                    if (!activeHighlights.has(elementId)) {
                        const highlight = createHighlight(h2, linkData.number);
                        activeHighlights.set(elementId, {
                            highlight: highlight,
                            element: h2,
                            number: linkData.number
                        });
                    } else {
                        // Update existing highlight position
                        const activeData = activeHighlights.get(elementId);
                        updateHighlight(h2, activeData.highlight);
                    }
                }
            });
            
            // Remove highlights for elements no longer visible
            for (const [elementId, activeData] of activeHighlights.entries()) {
                if (!currentlyVisible.has(elementId)) {
                    if (activeData.highlight && document.body.contains(activeData.highlight)) {
                        activeData.highlight.remove();
                    }
                    activeHighlights.delete(elementId);
                }
            }
            
            const visibleCount = activeHighlights.size;
            const totalDiscovered = processedLinks.size;
            
            console.log(`Visible: ${visibleCount} organic highlights | Total organic discovered: ${totalDiscovered} links`);
        }
        
        // Activate highlighting function
        window.activateBingH2Highlighting = () => {
            isHighlightingActive = true;
            
            // Process immediately
            processH2Elements();
            
            // Set up observers for dynamic content
            const observer = new MutationObserver(() => {
                if (isHighlightingActive) {
                    setTimeout(processH2Elements, 100);
                }
            });
            
            observer.observe(document.body, {
                childList: true,
                subtree: true
            });
            
            // Update on scroll with throttling
            let scrollTimeout;
            window.addEventListener('scroll', () => {
                if (isHighlightingActive) {
                    clearTimeout(scrollTimeout);
                    scrollTimeout = setTimeout(processH2Elements, 50);
                }
            }, { passive: true });
            
            // Update on resize
            window.addEventListener('resize', () => {
                if (isHighlightingActive) {
                    setTimeout(processH2Elements, 100);
                }
            }, { passive: true });
            
            console.log('Bing ORGANIC H2 highlighting activated with persistent numbering (excludes AI summaries, sponsored content)');
            return activeHighlights.size;
        };
        
        // Get info about highlighted links
        window.getHighlightedLinksInfo = () => {
            const links = [];
            
            for (const [elementId, data] of activeHighlights.entries()) {
                const h2 = data.element;
                if (!h2 || !document.body.contains(h2)) continue;
                
                // Find the actual link
                let linkElement = h2.querySelector('a');
                if (!linkElement) {
                    linkElement = h2.closest('a');
                }
                
                if (linkElement) {
                    links.push({
                        number: data.number,
                        title: h2.textContent.trim(),
                        url: linkElement.href,
                        domain: new URL(linkElement.href).hostname
                    });
                }
            }
            
            return links.sort((a, b) => a.number - b.number);
        };
        
        // Clear highlights function
        window.clearBingH2Highlights = () => {
            isHighlightingActive = false;
            
            // Remove all visible highlights
            document.querySelectorAll('.bing-h2-highlight').forEach(el => el.remove());
            activeHighlights.clear();
            
            console.log('Bing H2 highlights cleared');
        };
        
        return 'Bing H2 highlighter with persistent numbering injected successfully';
    }
    """
    
    result = await page.evaluate(js_code)
    return result

async def accept_cookies(page):
    """Accept Bing cookies if the dialog appears"""
    try:
        # Wait for potential cookie dialog
        await page.wait_for_timeout(1000)
        
        # Common Bing cookie accept button selectors
        cookie_selectors = [
            'button:has-text("Accept")',
            'button:has-text("I agree")',
            'button:has-text("Accept all")',
            '#bnp_btn_accept',
            'button#bnp_btn_accept',
            'button[aria-label="Accept"]',
            '.bnp_btn_accept',
            '#onetrust-accept-btn-handler'
        ]
        
        # Try each selector
        for selector in cookie_selectors:
            try:
                button = page.locator(selector).first
                if await button.count() > 0 and await button.is_visible():
                    await button.click()
                    print("‚úÖ Cookies accepted")
                    await page.wait_for_timeout(1000)
                    return True
            except:
                continue
                
        print("‚ÑπÔ∏è  No cookie dialog found")
        return False
        
    except Exception as e:
        print(f"‚ö†Ô∏è  Cookie handling: {str(e)}")
        return False

async def search_bing(page, query):
    """Perform a Bing search"""
    try:
        # Wait a bit for page to fully load
        await page.wait_for_timeout(2000)
        
        # Try multiple search box selectors for Bing
        search_selectors = [
            'input[id="sb_form_q"]',  # Main Bing search box ID
            'input[name="q"]',
            'input.b_searchbox',
            '#sb_form_q',
            'textarea[name="q"]'
        ]
        
        search_box = None
        for selector in search_selectors:
            try:
                if await page.locator(selector).count() > 0:
                    search_box = page.locator(selector).first
                    print(f"‚úÖ Found search box: {selector}")
                    break
            except:
                continue
        
        if not search_box:
            print("‚ùå Could not find search box")
            return False
            
        # Click and fill the search box
        await search_box.click()
        await page.wait_for_timeout(500)
        await search_box.fill(query)
        await page.wait_for_timeout(500)
        
        # Press Enter to search
        await search_box.press("Enter")
        
        # Wait for results to load - Bing uses H2 elements
        await page.wait_for_selector('h2', timeout=15000)
        await page.wait_for_timeout(2000)  # Extra time for all results
        
        print(f"‚úÖ Search completed")
        return True
        
    except Exception as e:
        print(f"‚ùå Search error: {str(e)}")
        return False

async def collect_highlighted_links(page, max_links=4):
    """Scroll and collect highlighted ORGANIC links (excludes AI summaries and sponsored content)"""
    collected_links = []
    collected_urls = set()
    scroll_attempts = 0
    max_scroll_attempts = 20
    
    print(f"\nüìå Collecting ORGANIC links (filtering out AI summaries & sponsored content)...")
    
    while len(collected_links) < max_links and scroll_attempts < max_scroll_attempts:
        # Get current highlighted links
        current_links = await page.evaluate("window.getHighlightedLinksInfo()")
        
        # Add new links to collection
        for link in current_links:
            if link['url'] not in collected_urls and len(collected_links) < max_links:
                # Skip Bing/Microsoft links
                if 'bing.com' in link['domain'] or 'microsoft.com' in link['domain']:
                    continue
                    
                collected_links.append(link)
                collected_urls.add(link['url'])
                
                # Show progress
                progress = '‚ñ†' * len(collected_links) + '‚ñ°' * (max_links - len(collected_links))
                print(f"   [{progress}] {len(collected_links)}/{max_links} organic links collected")
        
        # If we have enough links, stop
        if len(collected_links) >= max_links:
            break
            
        # Scroll down
        await page.evaluate("window.scrollBy(0, 400)")
        await page.wait_for_timeout(1500)
        
        scroll_attempts += 1
        
        # Check if at bottom
        at_bottom = await page.evaluate("""
            () => {
                return (window.innerHeight + window.scrollY) >= document.body.scrollHeight - 100;
            }
        """)
        
        if at_bottom:
            print("   ‚ÑπÔ∏è  Reached end of results")
            break
    
    if len(collected_links) < max_links:
        print(f"   ‚ö†Ô∏è  Only found {len(collected_links)} organic links (AI summaries and ads filtered out)")
    
    return collected_links

async def main():
    print("\n" + "="*60)
    print("üîç BING ORGANIC SEARCH LINK COLLECTOR")
    print("="*60)
    print("‚úÖ Collects ONLY organic search results")
    print("‚ùå Filters out: AI summaries, sponsored content, ads")
    print("="*60 + "\n")
    
    # Get search query - keep asking until we get one
    query = ""
    while not query.strip():
        query = input("Enter search query: ").strip()
        if not query:
            print("‚ö†Ô∏è  Please enter a search query!\n")
    
    print(f"\nüîÑ Searching Bing for: '{query}'...")
    
    async with async_playwright() as p:
        # Launch browser
        browser = await p.chromium.launch(
            headless=False,
            args=[
                '--disable-blink-features=AutomationControlled',
                '--no-sandbox',
                '--disable-infobars',
                '--disable-dev-shm-usage',
                '--disable-web-security',
                '--disable-features=IsolateOrigins,site-per-process',
                '--start-maximized'
            ]
        )
        
        context = await browser.new_context(
            viewport={'width': 1280, 'height': 720},
            user_agent='Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
            bypass_csp=True,
            ignore_https_errors=True
        )
        
        page = await context.new_page()
        
        try:
            # Navigate to Bing
            print("üìç Opening Bing...")
            await page.goto("https://www.bing.com", wait_until='domcontentloaded')
            await page.wait_for_timeout(3000)  # Give page time to fully load
            
            # Accept cookies
            await accept_cookies(page)
            
            # Perform search
            search_success = await search_bing(page, query)
            if not search_success:
                print("\n‚ö†Ô∏è  Trying alternative search method...")
                # Try to see what's on the page
                try:
                    # Take a screenshot for debugging
                    await page.screenshot(path="bing_error.png")
                    print("üì∏ Screenshot saved as bing_error.png")
                    
                    # Try to find any input field
                    inputs = await page.locator('input').all()
                    print(f"‚ÑπÔ∏è  Found {len(inputs)} input fields on page")
                    
                    # Wait a bit more and retry
                    await page.wait_for_timeout(3000)
                    search_success = await search_bing(page, query)
                except:
                    pass
                    
            if not search_success:
                print("‚ùå Search failed. Exiting...")
                await browser.close()
                return
            
            # Inject and activate highlighter
            await inject_bing_h2_highlighter(page)
            await page.wait_for_timeout(500)
            
            # Activate highlighting
            await page.evaluate("window.activateBingH2Highlighting()")
            print("‚úÖ Organic link highlighter activated (AI & ads filtered)")
            await page.wait_for_timeout(1000)
            
            # Collect links
            links = await collect_highlighted_links(page, max_links=4)
            
            # Display results
            print("\n" + "="*60)
            print("üìä ORGANIC SEARCH RESULTS:")
            print("="*60)
            
            if links:
                for i, link in enumerate(links, 1):
                    print(f"\n{i}. {link['title'][:70]}{'...' if len(link['title']) > 70 else ''}")
                    print(f"   üîó {link['url']}")
                    print(f"   üìç {link['domain']}")
            else:
                print("\n‚ùå No organic links found. Bing may be showing only AI summaries or ads for this query.")
            
            print("\n" + "="*60)
            print("‚úÖ Done! Browser will stay open for review...")
            print("="*60)
            
            # Keep browser open for user review
            input("\nPress Enter to close the browser and exit...")
            
        except Exception as e:
            print(f"\n‚ùå Error occurred: {str(e)}")
            import traceback
            traceback.print_exc()
            
        finally:
            await browser.close()

if __name__ == "__main__":
    try:
        asyncio.run(main())
    except KeyboardInterrupt:
        print("\n\n‚ö†Ô∏è  Cancelled by user.")
    except Exception as e:
        print(f"\n‚ùå Fatal error: {str(e)}")